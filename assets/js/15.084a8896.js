(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{589:function(t,v,_){t.exports=_.p+"assets/img/image-20240303153600981.3d8df640.png"},590:function(t,v,_){t.exports=_.p+"assets/img/image-20240303162428351.d7c26492.png"},591:function(t,v,_){t.exports=_.p+"assets/img/image-20240303162243210.77efa80c.png"},592:function(t,v,_){t.exports=_.p+"assets/img/image-20240303162606435.d1455613.png"},593:function(t,v,_){t.exports=_.p+"assets/img/image-20240303163508353.19e1304b.png"},594:function(t,v,_){t.exports=_.p+"assets/img/image-20240303164159831.e8dacae7.png"},595:function(t,v,_){t.exports=_.p+"assets/img/image-20240303164221045.df15686f.png"},596:function(t,v,_){t.exports=_.p+"assets/img/image-20240303172903758.9fb80920.png"},597:function(t,v,_){t.exports=_.p+"assets/img/image-20240303173239244.e4f0dd03.png"},598:function(t,v,_){t.exports=_.p+"assets/img/image-20240303173413798.cec6ced6.png"},599:function(t,v,_){t.exports=_.p+"assets/img/image-20240303174031547.e9d81567.png"},600:function(t,v,_){t.exports=_.p+"assets/img/image-20240303175013715.9d376c15.png"},601:function(t,v,_){t.exports=_.p+"assets/img/image-20240303175723851.cbb462da.png"},602:function(t,v,_){t.exports=_.p+"assets/img/image-20240303175934285.5c1d3b00.png"},665:function(t,v,_){"use strict";_.r(v);var s=_(14),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"开放最短路径优先ospf的基本工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开放最短路径优先ospf的基本工作原理"}},[t._v("#")]),t._v(" 开放最短路径优先OSPF的基本工作原理")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("开放最短路径优先OSPF（Open Shorted Path First），是为克服RIP的缺点在1989年开发出来的")]),t._v(" "),v("ul",[v("li",[t._v("“开放”表明OSPF协议不是受某一家厂商控制，而是"),v("font",{attrs:{color:"#EA0000"}},[t._v("公开发表")]),t._v("的")],1),t._v(" "),v("li",[t._v("“最短路径优先” 是因为使用了Dijkstra提出的"),v("font",{attrs:{color:"#EA0000"}},[t._v("最短路径算法")]),t._v("SPF")],1)])]),t._v(" "),v("li",[v("p",[t._v("OSPF是"),v("font",{attrs:{color:"#EA0000"}},[t._v("基于链路状态")]),t._v("的，而不像RIP那样是基于距离向量的")],1)]),t._v(" "),v("li",[v("p",[t._v("OSPF采用SPF算法计算路由，从算法上保证了"),v("font",{attrs:{color:"#EA0000"}},[t._v("不会产生路由环路")])],1)]),t._v(" "),v("li",[v("p",[t._v("OSPF"),v("font",{attrs:{color:"#EA0000"}},[t._v("不限制网络规模")]),t._v("，更新效率高，"),v("font",{attrs:{color:"#EA0000"}},[t._v("收敛速度快")])],1)]),t._v(" "),v("li",[v("p",[t._v("链路状态是指本路由器都"),v("font",{attrs:{color:"#EA0000"}},[t._v("和哪些路由器相邻")]),t._v("，以及相应的"),v("font",{attrs:{color:"#EA0000"}},[t._v("链路的“代价”")]),t._v("（cost）")],1),t._v(" "),v("ul",[v("li",[v("p",[t._v("“代价”用来表示费用、距离、时延、带宽等待，这些都由网络管理人员来决定")]),t._v(" "),v("p",[v("img",{attrs:{src:_(589),alt:"image-20240303153600981"}})])])])]),t._v(" "),v("li",[v("p",[t._v("OSPF相邻路由器之间通过交互"),v("font",{attrs:{color:"#aa00ff"}},[v("strong",[t._v("问候（Hello）分组")])]),t._v("，建立和维护"),v("font",{attrs:{color:"#EA0000"}},[t._v("邻居关系")])],1),t._v(" "),v("p",[t._v("如图所示：")]),t._v(" "),v("p",[v("img",{attrs:{src:_(590),alt:"image-20240303162428351"}})]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Hello分组封装在IP数据报中发送，发往组播地址224.0.0.5（协议为89表明是OSPF分组）")]),t._v(" "),v("p",[v("img",{attrs:{src:_(591),alt:"image-20240303162243210"}})])]),t._v(" "),v("li",[v("p",[t._v("发送周期为10秒")])]),t._v(" "),v("li",[v("p",[t._v("40秒未收到来自邻居路由器的Hello分组，则认为该邻居路由器不可达")]),t._v(" "),v("p",[v("img",{attrs:{src:_(592),alt:"image-20240303162606435"}})])])])]),t._v(" "),v("li",[v("p",[t._v("使用OSPF的每个路由器都会产生"),v("font",{attrs:{color:"#EA0000"}},[t._v("链路状态通告LSA")]),t._v("（Link State Advertisement）")],1),t._v(" "),v("ul",[v("li",[t._v("直连网络的链路状态信息")]),t._v(" "),v("li",[t._v("邻居路由器的链路状态信息")])])]),t._v(" "),v("li",[v("p",[t._v("LSA被封装在"),v("font",{attrs:{color:"#8600FF"}},[t._v("链路状态更新分组"),v("strong",[t._v("LSU")])]),t._v("中，采用"),v("font",{attrs:{color:"#EA0000"}},[t._v("洪泛法")]),t._v("发送（收到链路状态更新分组的路由器，将从自己其他所有接口转发该分组，进行洪泛转发）")],1)]),t._v(" "),v("li",[v("p",[t._v("使用OSPF的每个路由都有一个"),v("font",{attrs:{color:"#8600FF"}},[v("strong",[t._v("链路状态数据库LSDB")])]),t._v("，用于存储LSA")],1)]),t._v(" "),v("li",[v("p",[t._v("通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致")]),t._v(" "),v("p",[v("img",{attrs:{src:_(593),alt:"image-20240303163508353"}})])]),t._v(" "),v("li",[v("p",[t._v("使用OSPF的各路由器"),v("font",{attrs:{color:"#EA0000"}},[v("strong",[t._v("基于LSDB进行最短路径优先SPF计算")])]),t._v("，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。")],1),t._v(" "),v("p",[t._v("例如，如下的网络拓扑中，各链路旁的数字表示代价，通过上述洪泛发送各链路状态更新分组，各路由器最终会得出相同的链路状态数据库，由链路状态数据库可以得出带权有向图")]),t._v(" "),v("p",[v("img",{attrs:{src:_(594),alt:"image-20240303164159831"}})]),t._v(" "),v("p",[t._v("对该图进行Dijkstra的最短路径优先算法，就可以得出以各路由器为根的最短路径")]),t._v(" "),v("p",[v("img",{attrs:{src:_(595),alt:"image-20240303164221045"}})])]),t._v(" "),v("li",[v("p",[t._v("OSPF有以下五种分组类型：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("类型1，"),v("font",{attrs:{color:"#EA0000"}},[t._v("问候")]),t._v("（Hello）分组")],1),t._v(" "),v("p",[t._v("用来发现和维护邻居路由器的可达性")])]),t._v(" "),v("li",[v("p",[t._v("类型2，"),v("font",{attrs:{color:"#EA0000"}},[t._v("数据库描述")]),t._v("（Database Description）分组")],1),t._v(" "),v("p",[t._v("向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息")])]),t._v(" "),v("li",[v("p",[t._v("类型3，"),v("font",{attrs:{color:"#EA0000"}},[t._v("链路状态请求")]),t._v("（Link State Request）分组")],1),t._v(" "),v("p",[t._v("向邻居路由器请求发送某些链路状态项目的详细信息")])]),t._v(" "),v("li",[v("p",[t._v("类型4，"),v("font",{attrs:{color:"#EA0000"}},[t._v("链路状态更新")]),t._v("（Link State Update）分组")],1),t._v(" "),v("p",[t._v("路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛对全网更新链路状态")])]),t._v(" "),v("li",[v("p",[t._v("类型5，"),v("font",{attrs:{color:"#EA0000"}},[t._v("链路状态确认")]),t._v("（Link State Acknowledgment）分组")],1),t._v(" "),v("p",[t._v("这是对链路状态更新分组的确认分组")])])])])]),t._v(" "),v("h2",{attrs:{id:"ospf的基本工作过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ospf的基本工作过程"}},[t._v("#")]),t._v(" OSPF的基本工作过程：")]),t._v(" "),v("ul",[v("li",[t._v("相邻路由器之间周期性发送问候分组，以便建立和维护邻居关系")]),t._v(" "),v("li",[t._v("建立邻居关系后，给邻居路由器发送数据库描述分组（将自己的链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器）")]),t._v(" "),v("li",[t._v("例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组")]),t._v(" "),v("li",[t._v("R2收到后，将R1所缺少的链路状态项目的详细信息封装在链路状态更新分组中发送给R1；")]),t._v(" "),v("li",[t._v("R1收到后添加到自己的链路状态数据库中，并给R2发送链路状态确认分组")]),t._v(" "),v("li",[t._v("最终R1和R2的链路状态数据库达到同步")]),t._v(" "),v("li",[t._v("后面，每30分组或链路状态发生变化时，路由器都会发送链路状态更新分组，收到该分组的其他路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组（这又称为新情况下的链路状态数据库同步）")])]),t._v(" "),v("p",[v("img",{attrs:{src:_(596),alt:"image-20240303172903758"}})]),t._v(" "),v("h3",{attrs:{id:"ospf在多点接入网络中路由器邻居关系的建立"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ospf在多点接入网络中路由器邻居关系的建立"}},[t._v("#")]),t._v(" OSPF在多点接入网络中路由器邻居关系的建立")]),t._v(" "),v("p",[t._v("当OSPF路由器在多点接入网络中建立邻居关系时，如果不采用其他机制，将会产生大量的多播分组")]),t._v(" "),v("p",[t._v("例如，下图5台路由器连接在同一个多点接入网络中，周期性地发送问候分组以建立和维护邻居关系")]),t._v(" "),v("p",[v("img",{attrs:{src:_(597),alt:"image-20240303173239244"}})]),t._v(" "),v("p",[t._v("这些路由器中的任意两个路由器都互为邻居关系，如图所示：")]),t._v(" "),v("p",[v("img",{attrs:{src:_(598),alt:"image-20240303173413798"}})]),t._v(" "),v("p",[t._v("邻居关系的数量为 n(n-1)/2，其中n是路由器数量，每个路由器要向其他(n-1)个路由器发送问候分组，和链路状态更新分组")]),t._v(" "),v("p",[t._v("为了减少所发送分组的数量，")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("OSPF采用 选举"),v("font",{attrs:{color:"#EA0000"}},[t._v("指定路由器DR")]),t._v("（designated router）和"),v("font",{attrs:{color:"#EA0000"}},[t._v("备用指定路由器BDR")]),t._v("（backup designated router）")],1)]),t._v(" "),v("li",[v("p",[v("font",{attrs:{color:"#EA0000"}},[t._v("所有非DR/BDR只与DR/BDR建立邻居关系")]),t._v("，如图所示：")],1),t._v(" "),v("p",[v("img",{attrs:{src:_(599),alt:"image-20240303174031547"}})]),t._v(" "),v("p",[t._v("之前的邻居关系数量就降低为 2(n-2)+1")])]),t._v(" "),v("li",[v("p",[t._v("非DR/BDR之间必须通过DR/BDR交互信息")])])]),t._v(" "),v("h3",{attrs:{id:"区域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#区域"}},[t._v("#")]),t._v(" 区域")]),t._v(" "),v("p",[t._v("为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做"),v("font",{attrs:{color:"#EA0000"}},[t._v("区域")]),t._v("（Area）")],1),t._v(" "),v("p",[t._v("每个区域都有一个32比特的区域标识符，可以用点分十进制表示")]),t._v(" "),v("p",[t._v("例如，"),v("strong",[t._v("主干区域")]),t._v("为0.0.0.0，"),v("strong",[t._v("主干区域")]),t._v("用于"),v("font",{attrs:{color:"#EA0000"}},[t._v("连通其他区域")]),t._v("，其他区域标识符不能为0，且互不相同")],1),t._v(" "),v("p",[v("img",{attrs:{src:_(600),alt:"image-20240303175013715"}})]),t._v(" "),v("p",[t._v("每个区域的规模不应太大，一般所包含路由器不应超过200个；")]),t._v(" "),v("p",[t._v("划分区域的好处就是："),v("font",{staticStyle:{"background-color":"#ff0"}},[t._v("把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这样就减少了整个网络上的通信量")]),t._v("。")],1),t._v(" "),v("p",[t._v("如果所有路由器接口都在同一个区域内，则该路由器称为"),v("strong",[t._v("区域内路由器")])]),t._v(" "),v("p",[t._v("为了区域之间连通，每个区域都会有一个"),v("strong",[t._v("区域边界路由器")]),t._v("，它的一个接口用于连接自身所在区域，另一个接口用于连接主干区域")]),t._v(" "),v("p",[t._v("主干区域内的路由器，称为"),v("strong",[t._v("主干路由器")])]),t._v(" "),v("p",[t._v("在主干区域内，还要有一个路由器专门和本自治系统外的其他自治系统交换信息，称为"),v("strong",[t._v("自治系统边界路由器")])]),t._v(" "),v("p",[v("img",{attrs:{src:_(601),alt:"image-20240303175723851"}})]),t._v(" "),v("p",[t._v("各区域边界路由器转发的LSA：")]),t._v(" "),v("p",[v("img",{attrs:{src:_(602),alt:"image-20240303175934285"}})]),t._v(" "),v("p",[t._v("采用分层次划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做，却能使每个区域内部交换路由信息的通信量大大减少，因而使OSPF协议能够用于规模很大的自治系统中。")])])}),[],!1,null,null,null);v.default=a.exports}}]);